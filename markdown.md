## js基础

[什么是执行上下文]
  
  评估和执行JavaScript代码的环境的抽象概念。
  每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

[执行上下文的三种类型]
  - 全局执行上下文
    这是默认执行上下文，任何不在函数内部的代码都是全局执行上下文。一个程序只会有一个全局执行上下文
  - 函数执行上下文
    一个函数执行时都会创建新的上下文，每个函数都有。一个程序可以有任意个。
  - eval执行上下文
    执行在 eval 函数内部的代码也会有它属于自己的执行上下文。（很少用，不用多说）

[执行栈]
  是一种拥有“后进先出”数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

  - 运行js时，首先创建全局上下文，推到执行栈。
  - 每当调用函数，都会创建一个函数上下文并推到执行栈顶部。
  - js会执行那些位于顶部的执行栈，执行结束后执行上下文从栈中弹出，在执行下一个，以此类推。

[作用域链]

  每个函数都会有一个作用域，查找变量或函数时，由局部作用域到全局作用域依次查找，这些作用域的集合就称为作用域链。

[闭包]

  闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束。

[apply，call，bind区别](./js基础/apply_call_bind.js)

[原型，原型链](./js基础/原型和原型链.js)

[promise](./js基础/promise.js)(手写promise.all)

[深浅拷贝](./js基础/深浅拷贝.js)(手写深复制)

**[eventloop] || [js执行机制] || [事件循环机制]

什么叫是evnetloop？原理？
js是单线程的，排队执行，排队就是event loop。

什么是宏任务什么是微任务？
从上到下执行，分为“立即执行”、“宏任务”、“微任务”。
* 立即执行：全局的立即执行，同步代码
* 微任务（micro）：是立即执行和宏任务之间，执行栈完毕后清空微任务，才会执行宏任务（promise.then || catch, process.nextTick）
* 宏任务（macro）：也叫事件队列。一般属于异步代码 (整体的script代码, setTimeout, setInterval,   setImmediate, API, click)

执行顺序：
* 一开始整个脚本作为一个宏任务执行
* 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
* 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
* 执行浏览器UI线程的渲染工作
* 检查是否有Web Worker任务，有则执行
* 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

[什么是web worker]

* Web Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。
* 分别是专用线程和共享线程，其中专用线程只能为一个页面所使用，而共享线程则可以被多个页面所共享。
* 线程可以执行任务而不干扰用户界面。

[浏览器缓存](https://github.com/xiangxingchen/blog/issues/9)
原理：
* 第一次请求，会查看是否有这个请求的缓存，如果没有直接请求服务器，返回结果和缓存规则，然后将结果缓存到浏览器。
* 第二次请求，查看是否存在缓存，如果存在直接读取缓存，如果缓存过期，在请求服务器。
* 强制缓存要优先于协商缓存
  
什么叫缓存？
* 强缓存通过Expires和Cache-Control两种响应头实现 
  
  —————————————————————————————————

  Expires（过期时间又服务器返回，受限于本地时间，如果修改了本地时间，可能会造成缓存失效）（is pai 儿 si）

  Cache-Control（优先级高于 Expires ,表示的是相对时间）

* 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的
  
  —————————————————————————————————

  Last-Modified，If-Modified-Since（马 地 fai， 性斯）

  Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

  ETag、If-None-Match 

  Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的

  If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来

  **ETag的优先级比Last-Modified更高**

[new方法]

* 创建一个新对象。
* 这个新对象的 __proto__ 属性指向原函数的 prototype 属性(链接到原型)
* 将这个新对象绑定到 此函数的 this 上 。
* 返回新对象，如果这个函数没有返回其他对象。

字面量 与 Object.create(null) 创建对象的区别？

* new 和 字面量创建的对象的原型指向 Object.prototype，会继承 Object 的属性和方法。
* 而通过 Object.create(null) 创建的对象，其原型指向 null，null 作为原型链的顶端，没有也不会继承任何属性和方法。

[垃圾回收机制]

什么是内存泄漏？为什么会导致内存泄漏？
* 不再用到的内存，没有及时释放，就叫做内存泄漏。（js对象已经引用完了，浏览器认为还在引用，回收站不会回收它，然后就是内存泄漏了，如果这种情况越来越多，系统会崩溃）

怎么解决内存泄漏？
* js是有自动回收机制的。（标记清除法、引用计数法）
* 标记清除法：所有的变量都被标记，然后当离开环境后就被回收
* 引用计数法：当引用类型引用次数为0的时候，就被回收
* 闭包和全局变量，需要手动释放，赋值为null

[异步编程]
* JS 单线程的特点就是同一时刻只能执行一个任务，
* 但是单线程带来的问题就是会导致阻塞问题，为了解决这个问题，就不得不涉及 JS 的两种任务，分别为同步任务和异步任务

[响应码]
* **200: 请求成功**
* **301: 永久移动，返回信息会包括新的URII，浏览器会自动定向到新URI**
* **302 || 307: 临时移动**
* **304: 所请求的资源未修改，不会返回任何资源**
* 305: 必须通过代理访问
* **400: 客户端请求的语法错误**
* **401: 服务器验证登陆有问题**
* **403: 服务器验证权限出问题**
* 404: 服务器找不到网页
* 408: 服务器等待请求时间过长，超时
* 410: 客户端请求的资源已经不存在
* **500: 服务器内部错误，无法请求**
* 502: 服务器无效的响应
  

## vue

[MVVM](./vue/MVVM_响应式数据.js)

[生命周期](./vue/生命周期.js)

[状态管理](./vue/状态管理.js)

[组件通信](./vue/组件通信.js)

[虚拟dom](./vue/虚拟dom_diff.js)

[计算属性VS侦听属性]

computed: 是计算属性，单纯的计算数据变化而执行的逻辑，可以缓存。（一般来说用来对同步数据的处理）

watch：监听器，数据变化时执行某些复杂逻辑，watch有两个参数，deep是否深度和immediate是否立即执行。（可用于异步操作）

[高阶组件]

[vue与react区别]

## css
[position]
* static默认值（此时 top, right, bottom, left 和 z-index 属性无效）斯 打 忒
* relative相对定位（文档中的正常位置偏移,不影响其他元素的偏移）
* absolute 绝对定位（元素会被移出正常文档流，并不为元素预留空间，相对于除static之外的父元素或者祖先元素偏移）
* fixed 固定定位（元素会被移出正常文档流，并不为元素预留空间，相对于屏幕视口来偏移，页面滚动时位置不会改变）
* sticky 粘性定位（可以看出是position:relative和position:fixed的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed） 斯 忒 kei

[flex布局](./css/flex.js)

[布局方式]
* 文档流布局(就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行)
* 浮动布局(浮动方式布局就是使用 float 属性，使元素脱离文档流，浮动起来)
* 定位布局(通过 position 属性来进行定位)
* flex 布局
* 网格布局(没用过)
* 圣杯布局(没用过)三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。
  ```
    .container{
        padding: 0 200px;
    }
    .middle{
        width: 100%;
        background: paleturquoise;
        height: 200px;
        float: left;
    }
    .left{
        background: palevioletred;
        width: 200px;
        height: 200px;
        float: left;
        font-size: 40px;
        color: #fff;
        margin-left:-100%;


    }
    .right{
        width: 200px;
        height: 200px;
        background: purple;
        font-size: 40px;
        float: left;
        color: #fff;
        margin-left:-200px;

    }
  ```

[z-index]
* z-index值越大在Z轴上就越靠上
* 它仅在定位元素定义了position属性，且属性值为非static值的元素上有效果.

## 工程化（webpack）

## 性能优化

## 手写
[数组去重](./手写/数组去重.js)

[深拷贝](js基础/深浅拷贝.js)

[promise.all](js基础/promise.js)

[防抖、节流](./手写/防抖_节流.js)

[2个对象是否相等](./手写/两个对象是否相等.js)

[合并2个对象](./手写/合并对象.js)

[new](./手写/new.js)

## 原生

## 算法
[排序算法](./算法/排序.js)

[两数之和](./算法/两数之和.js)